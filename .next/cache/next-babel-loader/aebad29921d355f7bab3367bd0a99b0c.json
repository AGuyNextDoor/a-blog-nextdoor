{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = Image;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _head = _interopRequireDefault(require(\"../next-server/lib/head\"));\n\nvar VALID_LOADING_VALUES = ['lazy', 'eager', undefined];\nvar loaders = new Map([['imgix', imgixLoader], ['cloudinary', cloudinaryLoader], ['akamai', akamaiLoader], ['default', defaultLoader]]);\nvar imageData = process.env.__NEXT_IMAGE_OPTS;\nvar configDeviceSizes = imageData.deviceSizes,\n    configImageSizes = imageData.imageSizes,\n    configLoader = imageData.loader,\n    configPath = imageData.path,\n    configDomains = imageData.domains; // sort smallest to largest\n\nconfigDeviceSizes.sort(function (a, b) {\n  return a - b;\n});\nconfigImageSizes.sort(function (a, b) {\n  return a - b;\n});\nvar cachedObserver;\nvar IntersectionObserver = true ? window.IntersectionObserver : null;\n\nfunction getObserver() {\n  // Return shared instance of IntersectionObserver if already created\n  if (cachedObserver) {\n    return cachedObserver;\n  } // Only create shared IntersectionObserver if supported in browser\n\n\n  if (!IntersectionObserver) {\n    return undefined;\n  }\n\n  return cachedObserver = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      if (entry.isIntersecting) {\n        var lazyImage = entry.target;\n\n        if (lazyImage.dataset.src) {\n          lazyImage.src = lazyImage.dataset.src;\n        }\n\n        if (lazyImage.dataset.srcset) {\n          lazyImage.srcset = lazyImage.dataset.srcset;\n        }\n\n        lazyImage.style.visibility = 'visible';\n        lazyImage.classList.remove('__lazy');\n        cachedObserver.unobserve(lazyImage);\n      }\n    });\n  }, {\n    rootMargin: '200px'\n  });\n}\n\nfunction getDeviceSizes(width) {\n  if (typeof width !== 'number') {\n    return configDeviceSizes;\n  }\n\n  if (configImageSizes.includes(width)) {\n    return [width];\n  }\n\n  var widths = [];\n\n  var _iterator = _createForOfIteratorHelper(configDeviceSizes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var size = _step.value;\n      widths.push(size);\n\n      if (size >= width) {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return widths;\n}\n\nfunction computeSrc(src, unoptimized, width, quality) {\n  if (unoptimized) {\n    return src;\n  }\n\n  var widths = getDeviceSizes(width);\n  var largest = widths[widths.length - 1];\n  return callLoader({\n    src: src,\n    width: largest,\n    quality: quality\n  });\n}\n\nfunction callLoader(loaderProps) {\n  var load = loaders.get(configLoader) || defaultLoader;\n  return load((0, _extends2.default)({\n    root: configPath\n  }, loaderProps));\n}\n\nfunction generateSrcSet(_ref2) {\n  var src = _ref2.src,\n      unoptimized = _ref2.unoptimized,\n      width = _ref2.width,\n      quality = _ref2.quality;\n\n  // At each breakpoint, generate an image url using the loader, such as:\n  // ' www.example.com/foo.jpg?w=480 480w, '\n  if (unoptimized) {\n    return undefined;\n  }\n\n  return getDeviceSizes(width).map(function (w) {\n    return \"\".concat(callLoader({\n      src: src,\n      width: w,\n      quality: quality\n    }), \" \").concat(w, \"w\");\n  }).join(', ');\n}\n\nfunction generatePreload(_ref3) {\n  var src = _ref3.src,\n      width = _ref3.width,\n      _ref3$unoptimized = _ref3.unoptimized,\n      unoptimized = _ref3$unoptimized === void 0 ? false : _ref3$unoptimized,\n      sizes = _ref3.sizes,\n      quality = _ref3.quality;\n  // This function generates an image preload that makes use of the \"imagesrcset\" and \"imagesizes\"\n  // attributes for preloading responsive images. They're still experimental, but fully backward\n  // compatible, as the link tag includes all necessary attributes, even if the final two are ignored.\n  // See: https://web.dev/preload-responsive-images/\n  return /*#__PURE__*/_react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"link\", {\n    rel: \"preload\",\n    as: \"image\",\n    href: computeSrc(src, unoptimized, width, quality) // @ts-ignore: imagesrcset and imagesizes not yet in the link element type\n    ,\n    imagesrcset: generateSrcSet({\n      src: src,\n      unoptimized: unoptimized,\n      width: width,\n      quality: quality\n    }),\n    imagesizes: sizes\n  }));\n}\n\nfunction getInt(x) {\n  if (typeof x === 'number') {\n    return x;\n  }\n\n  if (typeof x === 'string') {\n    return parseInt(x, 10);\n  }\n\n  return undefined;\n}\n\nfunction Image(_ref) {\n  var src = _ref.src,\n      sizes = _ref.sizes,\n      _ref$unoptimized = _ref.unoptimized,\n      unoptimized = _ref$unoptimized === void 0 ? false : _ref$unoptimized,\n      _ref$priority = _ref.priority,\n      priority = _ref$priority === void 0 ? false : _ref$priority,\n      loading = _ref.loading,\n      className = _ref.className,\n      quality = _ref.quality,\n      width = _ref.width,\n      height = _ref.height,\n      unsized = _ref.unsized,\n      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"src\", \"sizes\", \"unoptimized\", \"priority\", \"loading\", \"className\", \"quality\", \"width\", \"height\", \"unsized\"]);\n  var thisEl = (0, _react.useRef)(null);\n\n  if (false) {\n    if (!src) {\n      throw new Error(\"Image is missing required \\\"src\\\" property. Make sure you pass \\\"src\\\" in props to the `next/image` component. Received: \".concat(JSON.stringify({\n        width: width,\n        height: height,\n        quality: quality,\n        unsized: unsized\n      })));\n    }\n\n    if (!VALID_LOADING_VALUES.includes(loading)) {\n      throw new Error(\"Image with src \\\"\".concat(src, \"\\\" has invalid \\\"loading\\\" property. Provided \\\"\").concat(loading, \"\\\" should be one of \").concat(VALID_LOADING_VALUES.map(String).join(','), \".\"));\n    }\n\n    if (priority && loading === 'lazy') {\n      throw new Error(\"Image with src \\\"\".concat(src, \"\\\" has both \\\"priority\\\" and \\\"loading=lazy\\\" properties. Only one should be used.\"));\n    }\n  }\n\n  var lazy = loading === 'lazy';\n\n  if (!priority && typeof loading === 'undefined') {\n    lazy = true;\n  }\n\n  (0, _react.useEffect)(function () {\n    var target = thisEl.current;\n\n    if (target && lazy) {\n      var observer = getObserver();\n\n      if (observer) {\n        observer.observe(target);\n        return function () {\n          observer.unobserve(target);\n        };\n      }\n    }\n  }, [thisEl, lazy]);\n  var widthInt = getInt(width);\n  var heightInt = getInt(height);\n  var qualityInt = getInt(quality);\n  var divStyle;\n  var imgStyle;\n  var wrapperStyle;\n\n  if (typeof widthInt !== 'undefined' && typeof heightInt !== 'undefined' && !unsized) {\n    // <Image src=\"i.png\" width={100} height={100} />\n    // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n    var quotient = heightInt / widthInt;\n    var ratio = isNaN(quotient) ? 1 : quotient * 100;\n    wrapperStyle = {\n      maxWidth: '100%',\n      width: widthInt\n    };\n    divStyle = {\n      position: 'relative',\n      paddingBottom: \"\".concat(ratio, \"%\")\n    };\n    imgStyle = {\n      visibility: lazy ? 'hidden' : 'visible',\n      height: '100%',\n      left: '0',\n      position: 'absolute',\n      top: '0',\n      width: '100%'\n    };\n  } else if (typeof widthInt === 'undefined' && typeof heightInt === 'undefined' && unsized) {\n    // <Image src=\"i.png\" unsized />\n    if (false) {\n      if (priority) {\n        // <Image src=\"i.png\" unsized priority />\n        console.warn(\"Image with src \\\"\".concat(src, \"\\\" has both \\\"priority\\\" and \\\"unsized\\\" properties. Only one should be used.\"));\n      }\n    }\n  } else {\n    // <Image src=\"i.png\" />\n    if (false) {\n      throw new Error(\"Image with src \\\"\".concat(src, \"\\\" must use \\\"width\\\" and \\\"height\\\" properties or \\\"unsized\\\" property.\"));\n    }\n  } // Generate attribute values\n\n\n  var imgSrc = computeSrc(src, unoptimized, widthInt, qualityInt);\n  var imgSrcSet = generateSrcSet({\n    src: src,\n    width: widthInt,\n    unoptimized: unoptimized,\n    quality: qualityInt\n  });\n  var imgAttributes;\n\n  if (!lazy) {\n    imgAttributes = {\n      src: imgSrc\n    };\n\n    if (imgSrcSet) {\n      imgAttributes.srcSet = imgSrcSet;\n    }\n  } else {\n    imgAttributes = {\n      'data-src': imgSrc\n    };\n\n    if (imgSrcSet) {\n      imgAttributes['data-srcset'] = imgSrcSet;\n    }\n\n    className = className ? className + ' __lazy' : '__lazy';\n  } // No need to add preloads on the client side--by the time the application is hydrated,\n  // it's too late for preloads\n\n\n  var shouldPreload = priority && false;\n  return /*#__PURE__*/_react.default.createElement(\"div\", {\n    style: wrapperStyle\n  }, /*#__PURE__*/_react.default.createElement(\"div\", {\n    style: divStyle\n  }, shouldPreload ? generatePreload({\n    src: src,\n    width: widthInt,\n    unoptimized: unoptimized,\n    sizes: sizes,\n    quality: qualityInt\n  }) : '', /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n    className: className,\n    sizes: sizes,\n    ref: thisEl,\n    style: imgStyle\n  }))));\n} //BUILT IN LOADERS\n\n\nfunction normalizeSrc(src) {\n  return src[0] === '/' ? src.slice(1) : src;\n}\n\nfunction imgixLoader(_ref4) {\n  var root = _ref4.root,\n      src = _ref4.src,\n      width = _ref4.width,\n      quality = _ref4.quality;\n  var params = ['auto=format', 'w=' + width];\n  var paramsString = '';\n\n  if (quality) {\n    params.push('q=' + quality);\n  }\n\n  if (params.length) {\n    paramsString = '?' + params.join('&');\n  }\n\n  return \"\".concat(root).concat(normalizeSrc(src)).concat(paramsString);\n}\n\nfunction akamaiLoader(_ref5) {\n  var root = _ref5.root,\n      src = _ref5.src,\n      width = _ref5.width;\n  return \"\".concat(root).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\n\nfunction cloudinaryLoader(_ref6) {\n  var root = _ref6.root,\n      src = _ref6.src,\n      width = _ref6.width,\n      quality = _ref6.quality;\n  var params = ['f_auto', 'w_' + width];\n  var paramsString = '';\n\n  if (quality) {\n    params.push('q_' + quality);\n  }\n\n  if (params.length) {\n    paramsString = params.join(',') + '/';\n  }\n\n  return \"\".concat(root).concat(paramsString).concat(normalizeSrc(src));\n}\n\nfunction defaultLoader(_ref7) {\n  var root = _ref7.root,\n      src = _ref7.src,\n      width = _ref7.width,\n      quality = _ref7.quality;\n\n  if (false) {\n    var missingValues = []; // these should always be provided but make sure they are\n\n    if (!src) missingValues.push('src');\n    if (!width) missingValues.push('width');\n\n    if (missingValues.length > 0) {\n      throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(', '), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n        src: src,\n        width: width,\n        quality: quality\n      })));\n    }\n\n    if (src && !src.startsWith('/') && configDomains) {\n      var parsedSrc;\n\n      try {\n        parsedSrc = new URL(src);\n      } catch (err) {\n        console.error(err);\n        throw new Error(\"Failed to parse \\\"\".concat(src, \"\\\" if using relative image it must start with a leading slash \\\"/\\\" or be an absolute URL\"));\n      }\n\n      if (!configDomains.includes(parsedSrc.hostname)) {\n        throw new Error(\"Invalid src prop (\".concat(src, \") on `next/image`, hostname is not configured under images in your `next.config.js`\"));\n      }\n    }\n  }\n\n  return \"\".concat(root, \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}","map":null,"metadata":{},"sourceType":"script"}