<body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <p>Programming a quantum computer is now something that anyone can do in the comfort of their own home.</p>
<p>But what to create? What is a quantum program anyway? In fact, what is a quantum computer?</p>
<p>These questions can be answered by making comparisons to standard digital computers. Unfortunately, most people don’t actually understand how digital computers work either. In this article, we’ll look at the basics principles behind these devices. To help us transition over to quantum computing later on, we’ll do it using the same tools as we’ll use for quantum.</p>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p><a class="reference external" href="#bits">Splitting information into bits</a></p></li>
<li><p><a class="reference external" href="#diagram">Computation as a Diagram</a></p></li>
<li><p><a class="reference external" href="#first-circuit">Your First Quantum Circuit</a></p></li>
<li><p><a class="reference external" href="#adder">Example: Adder Circuit</a><br />
4.1 <a class="reference external" href="#encoding">Encoding an Input</a><br />
4.2 <a class="reference external" href="#remembering-add">Remembering how to Add</a><br />
4.3 <a class="reference external" href="#adding-qiskit">Adding with Qiskit</a></p></li>
</ol>
<p>Below is some Python code we’ll need to run if we want to use the code in this page:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">execute</span><span class="p">,</span> <span class="n">Aer</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="splitting-information-into-bits-a-id-bits-a">
<h1>1. Splitting information into bits <a id="bits"></a><a class="headerlink" href="#splitting-information-into-bits-a-id-bits-a" title="Permalink to this headline">¶</a></h1>
<p>The first thing we need to know about is the idea of bits. These are designed to be the world’s simplest alphabet. With only two characters, 0 and 1, we can represent any piece of information.</p>
<p>One example is numbers. You are probably used to representing a number through a string of the ten digits 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. In this string of digits, each digit represents how many times the number contains a certain power of ten. For example, when we write 9213, we mean</p>
<div class="math notranslate nohighlight">
\[ 9000 + 200 + 10 + 3 \]</div>
<p>or, expressed in a way that emphasizes the powers of ten</p>
<div class="math notranslate nohighlight">
\[ (9\times10^3) + (2\times10^2) + (1\times10^1) + (3\times10^0) \]</div>
<p>Though we usually use this system based on the number 10, we can just as easily use one based on any other number. The binary number system, for example, is based on the number two. This means using the two characters 0 and 1 to express numbers as multiples of powers of two. For example, 9213 becomes 10001111111101, since</p>
<div class="math notranslate nohighlight">
\[\begin{split} 9213  = (1 \times 2^{13}) + (0 \times 2^{12}) + (0 \times 2^{11})+ (0 \times 2^{10}) +(1 \times 2^9) + (1 \times 2^8) + (1 \times 2^7) \\\\ \,\,\,   + (1 \times 2^6) + (1 \times 2^5) + (1 \times 2^4) + (1 \times 2^3) + (1 \times 2^2) + (0 \times 2^1) + (1 \times 2^0) \end{split}\]</div>
<p>In this we are expressing numbers as multiples of 2, 4, 8, 16, 32, etc. instead of 10, 100, 1000, etc.
<a id="binary_widget"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_textbook.widgets</span> <span class="kn">import</span> <span class="n">binary_widget</span>
<span class="n">binary_widget</span><span class="p">(</span><span class="n">nbits</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "a1040732a3184a6bb1d26a5a0a95bebb"}
</script><script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "132bd0ca6e1445a585075ac99937d447"}
</script></div>
</div>
<p>These strings of bits, known as binary strings, can be used to represent more than just numbers. For example, there is a way to represent any text using bits. For any letter, number, or punctuation mark you want to use, you can find a corresponding string of at most eight bits using <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.networkcomm/conversion_table.htm">this table</a>. Though these are quite arbitrary, this is a widely agreed-upon standard. In fact, it’s what was used to transmit this article to you through the internet.</p>
<p>This is how all information is represented in computers. Whether numbers, letters, images, or sound, it all exists in the form of binary strings.</p>
<p>Like our standard digital computers, quantum computers are based on this same basic idea. The main difference is that they use <em>qubits</em>, an extension of the bit to quantum mechanics. In the rest of this textbook, we will explore what qubits are, what they can do, and how they do it. In this section, however, we are not talking about quantum at all. So, we just use qubits as if they were bits.</p>
<div class="section" id="quick-exercises">
<h2>Quick Exercises<a class="headerlink" href="#quick-exercises" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Think of a number and try to write it down in binary.</p></li>
<li><p>If you have <span class="math notranslate nohighlight">\(n\)</span> bits, how many different states can they be in?</p></li>
</ol>
</div>
</div>
<div class="section" id="computation-as-a-diagram-a-id-diagram-a">
<h1>2. Computation as a diagram <a id="diagram"></a><a class="headerlink" href="#computation-as-a-diagram-a-id-diagram-a" title="Permalink to this headline">¶</a></h1>
<p>Whether we are using qubits or bits, we need to manipulate them in order to turn the inputs we have into the outputs we need. For the simplest programs with very few bits, it is useful to represent this process in a diagram known as a <em>circuit diagram</em>. These have inputs on the left, outputs on the right, and operations represented by arcane symbols in between. These operations are called ‘gates’, mostly for historical reasons.</p>
<p>Here’s an example of what a circuit looks like for standard, bit-based computers. You aren’t expected to understand what it does. It should simply give you an idea of what these circuits look like.</p>
<p><img alt="image1" src="images/classical_circuit.png" /></p>
<p>For quantum computers, we use the same basic idea but have different conventions for how to represent inputs, outputs, and the symbols used for operations. Here is the quantum circuit that represents the same process as above.</p>
<p><img alt="image2" src="images/quantum_circuit.png" /></p>
<p>In the rest of this section, we will explain how to build circuits. At the end, you’ll know how to create the circuit above, what it does, and why it is useful.</p>
</div>
<div class="section" id="your-first-quantum-circuit-a-id-first-circuit-a">
<h1>3. Your first quantum circuit <a id="first-circuit"></a><a class="headerlink" href="#your-first-quantum-circuit-a-id-first-circuit-a" title="Permalink to this headline">¶</a></h1>
<p>In a circuit, we typically need to do three jobs: First, encode the input, then do some actual computation, and finally extract an output. For your first quantum circuit, we’ll focus on the last of these jobs. We start by creating a circuit with eight qubits and eight outputs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">n_q</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">n_b</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">qc_output</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n_q</span><span class="p">,</span><span class="n">n_b</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This circuit, which we have called <code class="docutils literal notranslate"><span class="pre">qc_output</span></code>, is created by Qiskit using <code class="docutils literal notranslate"><span class="pre">QuantumCircuit</span></code>. The number <code class="docutils literal notranslate"><span class="pre">n_q</span></code> defines the number of qubits in the circuit. With <code class="docutils literal notranslate"><span class="pre">n_b</span></code> we define the number of output bits we will extract from the circuit at the end.</p>
<p>The extraction of outputs in a quantum circuit is done using an operation called <code class="docutils literal notranslate"><span class="pre">measure</span></code>. Each measurement tells a specific qubit to give an output to a specific output bit. The following code adds a <code class="docutils literal notranslate"><span class="pre">measure</span></code> operation to each of our eight qubits. The qubits and bits are both labelled by the numbers from 0 to 7 (because that’s how programmers like to do things). The command <code class="docutils literal notranslate"><span class="pre">qc.measure(j,j)</span></code> adds a measurement to our circuit <code class="docutils literal notranslate"><span class="pre">qc</span></code> that tells qubit <code class="docutils literal notranslate"><span class="pre">j</span></code> to write an output to bit <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_output</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     
q_0: 

q_1: 

q_2: 

q_3: 

q_4: 

q_5: 

q_6: 

q_7: 

c: 8/
     </pre></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">qc_output</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now that our circuit has something in it, let’s take a look at it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_output</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─┐                     
q_0: ┤M├─────────────────────
     └╥┘┌─┐                  
q_1: ─╫─┤M├──────────────────
      ║ └╥┘┌─┐               
q_2: ─╫──╫─┤M├───────────────
      ║  ║ └╥┘┌─┐            
q_3: ─╫──╫──╫─┤M├────────────
      ║  ║  ║ └╥┘┌─┐         
q_4: ─╫──╫──╫──╫─┤M├─────────
      ║  ║  ║  ║ └╥┘┌─┐      
q_5: ─╫──╫──╫──╫──╫─┤M├──────
      ║  ║  ║  ║  ║ └╥┘┌─┐   
q_6: ─╫──╫──╫──╫──╫──╫─┤M├───
      ║  ║  ║  ║  ║  ║ └╥┘┌─┐
q_7: ─╫──╫──╫──╫──╫──╫──╫─┤M├
      ║  ║  ║  ║  ║  ║  ║ └╥┘
c: 8/═╩══╩══╩══╩══╩══╩══╩══╩═
      0  1  2  3  4  5  6  7 </pre></div></div>
</div>
<p>Qubits are always initialized to give the output <code class="docutils literal notranslate"><span class="pre">0</span></code>. Since we don’t do anything to our qubits in the circuit above, this is exactly the result we’ll get when we measure them. We can see this by running the circuit many times and plotting the results in a histogram. We will find that the result is always <code class="docutils literal notranslate"><span class="pre">00000000</span></code>: a <code class="docutils literal notranslate"><span class="pre">0</span></code> from each qubit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">qc_output</span><span class="p">,</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/atoms-computation_20_0.png" src="_images/atoms-computation_20_0.png" />
</div>
</div>
<p>The reason for running many times and showing the result as a histogram is because quantum computers may have some randomness in their results. In this case, since we aren’t doing anything quantum, we get just the <code class="docutils literal notranslate"><span class="pre">00000000</span></code> result with certainty.</p>
<p>Note that this result comes from a quantum simulator, which is a standard computer calculating what an ideal quantum computer would do. Simulations are only possible for small numbers of qubits (~30 qubits), but they are nevertheless a very useful tool when designing your first quantum circuits. To run on a real device you simply need to replace <code class="docutils literal notranslate"><span class="pre">Aer.get_backend('qasm_simulator')</span></code> with the backend object of the device you want to use.</p>
</div>
<div class="section" id="example-creating-an-adder-circuit-a-id-adder-a">
<h1>4. Example: Creating an Adder Circuit <a id="adder"></a><a class="headerlink" href="#example-creating-an-adder-circuit-a-id-adder-a" title="Permalink to this headline">¶</a></h1>
<div class="section" id="encoding-an-input-a-id-encoding-a">
<h2>4.1 Encoding an input <a id="encoding"></a><a class="headerlink" href="#encoding-an-input-a-id-encoding-a" title="Permalink to this headline">¶</a></h2>
<p>Now let’s look at how to encode a different binary string as an input. For this, we need what is known as a NOT gate. This is the most basic operation that you can do in a computer. It simply flips the bit value: <code class="docutils literal notranslate"><span class="pre">0</span></code> becomes <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> becomes <code class="docutils literal notranslate"><span class="pre">0</span></code>. For qubits, it is an operation called <code class="docutils literal notranslate"><span class="pre">x</span></code> that does the job of the NOT.</p>
<p>Below we create a new circuit dedicated to the job of encoding and call it <code class="docutils literal notranslate"><span class="pre">qc_encode</span></code>. For now, we only specify the number of qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_encode</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">qc_encode</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="n">qc_encode</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">          
q_0: ─────

q_1: ─────

q_2: ─────

q_3: ─────

q_4: ─────

q_5: ─────

q_6: ─────
     ┌───┐
q_7: ┤ X ├
     └───┘</pre></div></div>
</div>
<p>Extracting results can be done using the circuit we have from before: <code class="docutils literal notranslate"><span class="pre">qc_output</span></code>. Adding the two circuits using <code class="docutils literal notranslate"><span class="pre">qc_encode</span> <span class="pre">+</span> <span class="pre">qc_output</span></code> creates a new circuit with everything needed to extract an output added at the end.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc_encode</span> <span class="o">+</span> <span class="n">qc_output</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">justify</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">          ┌─┐                     
q_0: ─────┤M├─────────────────────
          └╥┘┌─┐                  
q_1: ──────╫─┤M├──────────────────
           ║ └╥┘┌─┐               
q_2: ──────╫──╫─┤M├───────────────
           ║  ║ └╥┘┌─┐            
q_3: ──────╫──╫──╫─┤M├────────────
           ║  ║  ║ └╥┘┌─┐         
q_4: ──────╫──╫──╫──╫─┤M├─────────
           ║  ║  ║  ║ └╥┘┌─┐      
q_5: ──────╫──╫──╫──╫──╫─┤M├──────
           ║  ║  ║  ║  ║ └╥┘┌─┐   
q_6: ──────╫──╫──╫──╫──╫──╫─┤M├───
     ┌───┐ ║  ║  ║  ║  ║  ║ └╥┘┌─┐
q_7: ┤ X ├─╫──╫──╫──╫──╫──╫──╫─┤M├
     └───┘ ║  ║  ║  ║  ║  ║  ║ └╥┘
c: 8/══════╩══╩══╩══╩══╩══╩══╩══╩═
           0  1  2  3  4  5  6  7 </pre></div></div>
</div>
<p>Now we can run the combined circuit and look at the results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/atoms-computation_27_0.png" src="_images/atoms-computation_27_0.png" />
</div>
</div>
<p>Now our computer outputs the string <code class="docutils literal notranslate"><span class="pre">10000000</span></code> instead.</p>
<p>The bit we flipped, which comes from qubit 7, lives on the far left of the string. This is because Qiskit numbers the bits in a string from right to left. Some prefer to number their bits the other way around, but Qiskit’s system certainly has its advantages when we are using the bits to represent numbers. Specifically, it means that qubit 7 is telling us about how many <span class="math notranslate nohighlight">\(2^7\)</span>s we have in our number. So by flipping this bit, we’ve now written the number 128 in our simple 8-bit computer.</p>
<p>Now try out writing another number for yourself. You could do your age, for example. Just use a search engine to find out what the number looks like in binary (if it includes a ‘0b’, just ignore it), and then add some 0s to the left side if you are younger than 64.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_encode</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">qc_encode</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc_encode</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">qc_encode</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">          
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
q_2: ─────

q_3: ─────

q_4: ─────
     ┌───┐
q_5: ┤ X ├
     └───┘
q_6: ─────

q_7: ─────
          </pre></div></div>
</div>
<p>Now we know how to encode information in a computer. The next step is to process it: To take an input that we have encoded, and turn it into an output that we need.</p>
</div>
<div class="section" id="remembering-how-to-add-a-id-remembering-add-a">
<h2>4.2 Remembering how to add <a id="remembering-add"></a><a class="headerlink" href="#remembering-how-to-add-a-id-remembering-add-a" title="Permalink to this headline">¶</a></h2>
<p>To look at turning inputs into outputs, we need a problem to solve. Let’s do some basic maths. In primary school, you will have learned how to take large mathematical problems and break them down into manageable pieces. For example, how would you go about solving the following?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   9213
+  1854
=  ????
</pre></div>
</div>
<p>One way is to do it digit by digit, from right to left. So we start with 3+4</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   9213
+  1854
=  ???7
</pre></div>
</div>
<p>And then 1+5</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   9213
+  1854
=  ??67
</pre></div>
</div>
<p>Then we have 2+8=10. Since this is a two digit answer, we need to carry the one over to the next column.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   9213
+  1854
=  ?067
   ¹ 
</pre></div>
</div>
<p>Finally we have 9+1+1=11, and get our answer</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   9213
+  1854
= 11067
   ¹ 
</pre></div>
</div>
<p>This may just be simple addition, but it demonstrates the principles behind all algorithms. Whether the algorithm is designed to solve mathematical problems or process text or images, we always break big tasks down into small and simple steps.</p>
<p>To run on a computer, algorithms need to be compiled down to the smallest and simplest steps possible. To see what these look like, let’s do the above addition problem again but in binary.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   10001111111101
+  00011100111110
                                    
=  ??????????????
</pre></div>
</div>
<p>Note that the second number has a bunch of extra 0s on the left. This just serves to make the two strings the same length.</p>
<p>Our first task is to do the 1+0 for the column on the right. In binary, as in any number system, the answer is 1. We get the same result for the 0+1 of the second column.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   10001111111101
+  00011100111110

=  ????????????11 
</pre></div>
</div>
<p>Next, we have 1+1. As you’ll surely be aware, 1+1=2. In binary, the number 2 is written <code class="docutils literal notranslate"><span class="pre">10</span></code>, and so requires two bits. This means that we need to carry the 1, just as we would for the number 10 in decimal.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   10001111111101
+  00011100111110
=  ???????????011 
             ¹ 
</pre></div>
</div>
<p>The next column now requires us to calculate <code class="docutils literal notranslate"><span class="pre">1+1+1</span></code>. This means adding three numbers together, so things are getting complicated for our computer. But we can still compile it down to simpler operations, and do it in a way that only ever requires us to add two bits together. For this, we can start with just the first two 1s.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">1</span>
<span class="o">+</span>  <span class="mi">1</span>
<span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Now we need to add this <code class="docutils literal notranslate"><span class="pre">10</span></code> to the final <code class="docutils literal notranslate"><span class="pre">1</span></code> , which can be done using our usual method of going through the columns.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="mi">10</span>
<span class="o">+</span> <span class="mi">01</span>
<span class="o">=</span> <span class="mi">11</span>
</pre></div>
</div>
<p>The final answer is <code class="docutils literal notranslate"><span class="pre">11</span></code> (also known as 3).</p>
<p>Now we can get back to the rest of the problem. With the answer of  <code class="docutils literal notranslate"><span class="pre">11</span></code>, we have another carry bit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   10001111111101
+  00011100111110
=  ??????????1011
            ¹¹
</pre></div>
</div>
<p>So now we have another 1+1+1 to do. But we already know how to do that, so it’s not a big deal.</p>
<p>In fact, everything left so far is something we already know how to do. This is because, if you break everything down into adding just two bits, there are only four possible things you’ll ever need to calculate. Here are the four basic sums (we’ll write all the answers with two bits to be consistent).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="o">+</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">00</span> <span class="p">(</span><span class="ow">in</span> <span class="n">decimal</span><span class="p">,</span> <span class="n">this</span> <span class="ow">is</span> <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">0</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">01</span> <span class="p">(</span><span class="ow">in</span> <span class="n">decimal</span><span class="p">,</span> <span class="n">this</span> <span class="ow">is</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span><span class="o">+</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">01</span> <span class="p">(</span><span class="ow">in</span> <span class="n">decimal</span><span class="p">,</span> <span class="n">this</span> <span class="ow">is</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">(</span><span class="ow">in</span> <span class="n">decimal</span><span class="p">,</span> <span class="n">this</span> <span class="ow">is</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>This is called a <em>half adder</em>. If our computer can implement this, and if it can chain many of them together, it can add anything.</p>
</div>
<div class="section" id="adding-with-qiskit-a-id-adding-qiskit-a">
<h2>4.3 Adding with Qiskit <a id="adding-qiskit"></a><a class="headerlink" href="#adding-with-qiskit-a-id-adding-qiskit-a" title="Permalink to this headline">¶</a></h2>
<p>Let’s make our own half adder using Qiskit. This will include a part of the circuit that encodes the input, a part that executes the algorithm, and a part that extracts the result. The first part will need to be changed whenever we want to use a new input, but the rest will always remain the same.</p>
<p><img alt="image3" src="https://s3.us-south.cloud-object-storage.appdomain.cloud/strapi/04498f84a69d4e859afd19b2760ced24atoms6.png" /></p>
<p>The two bits we want to add are encoded in the qubits 0 and 1. The above example encodes a <code class="docutils literal notranslate"><span class="pre">1</span></code> in both these qubits, and so it seeks to find the solution of <code class="docutils literal notranslate"><span class="pre">1+1</span></code>. The result will be a string of two bits, which we will read out from the qubits 2 and 3. All that remains is to fill in the actual program, which lives in the blank space in the middle.</p>
<p>The dashed lines in the image are just to distinguish the different parts of the circuit (although they can have more interesting uses too). They are made by using the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> command.</p>
<p>The basic operations of computing are known as logic gates. We’ve already used the NOT gate, but this is not enough to make our half adder. We could only use it to manually write out the answers. Since we want the computer to do the actual computing for us, we’ll need some more powerful gates.</p>
<p>To see what we need, let’s take another look at what our half adder needs to do.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="o">+</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">00</span>
<span class="mi">0</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">01</span>
<span class="mi">1</span><span class="o">+</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">01</span>
<span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>The rightmost bit in all four of these answers is completely determined by whether the two bits we are adding are the same or different. So for <code class="docutils literal notranslate"><span class="pre">0+0</span></code> and <code class="docutils literal notranslate"><span class="pre">1+1</span></code>, where the two bits are equal, the rightmost bit of the answer comes out <code class="docutils literal notranslate"><span class="pre">0</span></code>. For <code class="docutils literal notranslate"><span class="pre">0+1</span></code> and <code class="docutils literal notranslate"><span class="pre">1+0</span></code>, where we are adding different bit values, the rightmost bit is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>To get this part of our solution correct, we need something that can figure out whether two bits are different or not. Traditionally, in the study of digital computation, this is called an XOR gate.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Input 1</p></th>
<th class="text-align:center head"><p>Input 2</p></th>
<th class="text-align:center head"><p>XOR Output</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>0</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>1</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>1</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0</p></td>
</tr>
</tbody>
</table>
<p>In quantum computers, the job of the XOR gate is done by the controlled-NOT gate. Since that’s quite a long name, we usually just call it the CNOT. In Qiskit its name is <code class="docutils literal notranslate"><span class="pre">cx</span></code>, which is even shorter. In circuit diagrams, it is drawn as in the image below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_cnot</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_cnot</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc_cnot</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">          
q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘</pre></div></div>
</div>
<p>This is applied to a pair of qubits. One acts as the control qubit (this is the one with the little dot). The other acts as the <em>target qubit</em> (with the big circle).</p>
<p>There are multiple ways to explain the effect of the CNOT. One is to say that it looks at its two input bits to see whether they are the same or different. Next, it overwrites the target qubit with the answer. The target becomes <code class="docutils literal notranslate"><span class="pre">0</span></code> if they are the same, and <code class="docutils literal notranslate"><span class="pre">1</span></code> if they are different.</p>
<img src="images/cnot_xor.svg">
<p>Another way of explaining the CNOT is to say that it does a NOT on the target if the control is <code class="docutils literal notranslate"><span class="pre">1</span></code>, and does nothing otherwise. This explanation is just as valid as the previous one (in fact, it’s the one that gives the gate its name).</p>
<p>Try the CNOT out for yourself by trying each of the possible inputs. For example, here’s a circuit that tests the CNOT with the input <code class="docutils literal notranslate"><span class="pre">01</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌───┐     ┌─┐   
q_0: ┤ X ├──■──┤M├───
     └───┘┌─┴─┐└╥┘┌─┐
q_1: ─────┤ X ├─╫─┤M├
          └───┘ ║ └╥┘
c: 2/═══════════╩══╩═
                0  1 </pre></div></div>
</div>
<p>If you execute this circuit, you’ll find that the output is <code class="docutils literal notranslate"><span class="pre">11</span></code>. We can think of this happening because of either of the following reasons.</p>
<ul class="simple">
<li><p>The CNOT calculates whether the input values are different and finds that they are, which means that it wants to output <code class="docutils literal notranslate"><span class="pre">1</span></code>. It does this by writing over the state of qubit 1 (which, remember, is on the left of the bit string), turning <code class="docutils literal notranslate"><span class="pre">01</span></code> into <code class="docutils literal notranslate"><span class="pre">11</span></code>.</p></li>
<li><p>The CNOT sees that qubit 0 is in state <code class="docutils literal notranslate"><span class="pre">1</span></code>, and so applies a NOT to qubit 1. This flips the <code class="docutils literal notranslate"><span class="pre">0</span></code> of qubit 1 into a <code class="docutils literal notranslate"><span class="pre">1</span></code>, and so turns <code class="docutils literal notranslate"><span class="pre">01</span></code> into <code class="docutils literal notranslate"><span class="pre">11</span></code>.</p></li>
</ul>
<p>Here is a table showing all the possible inputs and corresponding outputs of the CNOT gate:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Input (q1 q0)</p></th>
<th class="text-align:center head"><p>Output (q1 q0)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>00</p></td>
<td class="text-align:center"><p>00</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>01</p></td>
<td class="text-align:center"><p>11</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>10</p></td>
<td class="text-align:center"><p>10</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>11</p></td>
<td class="text-align:center"><p>01</p></td>
</tr>
</tbody>
</table>
<p>For our half adder, we don’t want to overwrite one of our inputs. Instead, we want to write the result on a different pair of qubits. For this, we can use two CNOTs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_ha</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># encode inputs in qubits 0 and 1</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># For a=0, remove this line. For a=1, leave it.</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># For b=0, remove this line. For b=1, leave it.</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1"># use cnots to write the XOR of the inputs on qubit 2</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1"># extract outputs</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># extract XOR value</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">qc_ha</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌───┐ ░            ░       
q_0: ┤ X ├─░───■────────░───────
     ├───┤ ░   │        ░       
q_1: ┤ X ├─░───┼────■───░───────
     └───┘ ░ ┌─┴─┐┌─┴─┐ ░ ┌─┐   
q_2: ──────░─┤ X ├┤ X ├─░─┤M├───
           ░ └───┘└───┘ ░ └╥┘┌─┐
q_3: ──────░────────────░──╫─┤M├
           ░            ░  ║ └╥┘
c: 2/══════════════════════╩══╩═
                           0  1 </pre></div></div>
</div>
<p>We are now halfway to a fully working half adder. We just have the other bit of the output left to do: the one that will live on qubit 4.</p>
<p>If you look again at the four possible sums, you’ll notice that there is only one case for which this is <code class="docutils literal notranslate"><span class="pre">1</span></code> instead of <code class="docutils literal notranslate"><span class="pre">0</span></code>: <code class="docutils literal notranslate"><span class="pre">1+1</span></code>=<code class="docutils literal notranslate"><span class="pre">10</span></code>. It happens only when both the bits we are adding are <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>To calculate this part of the output, we could just get our computer to look at whether both of the inputs are <code class="docutils literal notranslate"><span class="pre">1</span></code>. If they are — and only if they are — we need to do a NOT gate on qubit 4. That will flip it to the required value of <code class="docutils literal notranslate"><span class="pre">1</span></code> for this case only, giving us the output we need.</p>
<p>For this, we need a new gate: like a CNOT but controlled on two qubits instead of just one. This will perform a NOT on the target qubit only when both controls are in state <code class="docutils literal notranslate"><span class="pre">1</span></code>. This new gate is called the <em>Toffoli</em>. For those of you who are familiar with Boolean logic gates, it is basically an AND gate.</p>
<p>In Qiskit, the Toffoli is represented with the <code class="docutils literal notranslate"><span class="pre">ccx</span></code> command.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qc_ha</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># encode inputs in qubits 0 and 1</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># For a=0, remove the this line. For a=1, leave it.</span>
<span class="c1"># qc_ha.x(1) # For b=0, remove the this line. For b=1, leave it.</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1"># use cnots to write the XOR of the inputs on qubit 2</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># use ccx to write the AND of the inputs on qubit 3</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1"># extract outputs</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># extract XOR value</span>
<span class="n">qc_ha</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># extract AND value</span>

<span class="n">qc_ha</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌───┐ ░                 ░       
q_0: ┤ X ├─░───■─────────■───░───────
     └───┘ ░   │         │   ░       
q_1: ──────░───┼────■────■───░───────
           ░ ┌─┴─┐┌─┴─┐  │   ░ ┌─┐   
q_2: ──────░─┤ X ├┤ X ├──┼───░─┤M├───
           ░ └───┘└───┘┌─┴─┐ ░ └╥┘┌─┐
q_3: ──────░───────────┤ X ├─░──╫─┤M├
           ░           └───┘ ░  ║ └╥┘
c: 2/═══════════════════════════╩══╩═
                                0  1 </pre></div></div>
</div>
<p>In this example, we are calculating <code class="docutils literal notranslate"><span class="pre">1+1</span></code>, because the two input bits are both <code class="docutils literal notranslate"><span class="pre">1</span></code>. Let’s see what we get.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">qc_ha</span><span class="p">,</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/atoms-computation_45_0.png" src="_images/atoms-computation_45_0.png" />
</div>
</div>
<p>The result is <code class="docutils literal notranslate"><span class="pre">10</span></code>, which is the binary representation of the number 2. We have built a computer that can solve the famous mathematical problem of 1+1!</p>
<p>Now you can try it out with the other three possible inputs, and show that our algorithm gives the right results for those too.</p>
<p>The half adder contains everything you need for addition. With the NOT, CNOT, and Toffoli gates, we can create programs that add any set of numbers of any size.</p>
<p>These three gates are enough to do everything else in computing too. In fact, we can even do without the CNOT. Additionally, the NOT gate is only really needed to create bits with value <code class="docutils literal notranslate"><span class="pre">1</span></code>. The Toffoli gate is essentially the atom of mathematics. It is the simplest element, from which every other problem-solving technique can be compiled.</p>
<p>As we’ll see, in quantum computing we split the atom.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit</span>
<span class="n">qiskit</span><span class="o">.</span><span class="n">__qiskit_version__</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;qiskit-terra&#39;: &#39;0.15.1&#39;,
 &#39;qiskit-aer&#39;: &#39;0.6.1&#39;,
 &#39;qiskit-ignis&#39;: &#39;0.4.0&#39;,
 &#39;qiskit-ibmq-provider&#39;: &#39;0.8.0&#39;,
 &#39;qiskit-aqua&#39;: &#39;0.7.5&#39;,
 &#39;qiskit&#39;: &#39;0.20.0&#39;}
</pre></div>
</div>
</div>
</div>
</div>
</div>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"1424d258ad27467d8ed10348f9adcc16": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "a3251188439446a08e35d5cc64745937": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "132bd0ca6e1445a585075ac99937d447": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_1424d258ad27467d8ed10348f9adcc16", "placeholder": "\u200b", "style": "IPY_MODEL_a3251188439446a08e35d5cc64745937", "value": "<pre>Binary   Decimal\n 00000 = 0</pre>"}}, "a55029259d2d4f1abb83acdf5f2acd09": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "3em", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": "3em"}}, "cf3c05f10c55422cbf11de87511f31e7": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "b1bd45af4b2747b4890c52aa2e6464c5": {"model_name": "ToggleButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ToggleButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ToggleButtonView", "button_style": "", "description": "16", "description_tooltip": null, "disabled": false, "icon": "", "layout": "IPY_MODEL_a55029259d2d4f1abb83acdf5f2acd09", "style": "IPY_MODEL_cf3c05f10c55422cbf11de87511f31e7", "tooltip": "", "value": false}}, "a9eeb503a7e04ef4bcb4b748f7866e8f": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "3em", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": "3em"}}, "3932454bb8ed49b8bd9ccd3fc8d7dbdb": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "f202f1296de146bca1abbb440e30d529": {"model_name": "ToggleButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ToggleButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ToggleButtonView", "button_style": "", "description": "8", "description_tooltip": null, "disabled": false, "icon": "", "layout": "IPY_MODEL_a9eeb503a7e04ef4bcb4b748f7866e8f", "style": "IPY_MODEL_3932454bb8ed49b8bd9ccd3fc8d7dbdb", "tooltip": "", "value": false}}, "03df53f2d5de4a8081c0dd9530b50300": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "3em", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": "3em"}}, "91b3016f554b4409997b6e4a2427ef43": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "69015928a71444e4a976278b2ab212c1": {"model_name": "ToggleButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ToggleButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ToggleButtonView", "button_style": "", "description": "4", "description_tooltip": null, "disabled": false, "icon": "", "layout": "IPY_MODEL_03df53f2d5de4a8081c0dd9530b50300", "style": "IPY_MODEL_91b3016f554b4409997b6e4a2427ef43", "tooltip": "", "value": false}}, "2dc9f3b5aa584d79a44a53e8606d320c": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "3em", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": "3em"}}, "bec4305c0b2546a2a6f7830dd7f67ac2": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "01dac76d841c428785b73addca4e736f": {"model_name": "ToggleButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ToggleButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ToggleButtonView", "button_style": "", "description": "2", "description_tooltip": null, "disabled": false, "icon": "", "layout": "IPY_MODEL_2dc9f3b5aa584d79a44a53e8606d320c", "style": "IPY_MODEL_bec4305c0b2546a2a6f7830dd7f67ac2", "tooltip": "", "value": false}}, "db03e6cc86874ac5ae11261a93b0bcd7": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "3em", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": "3em"}}, "f27b637a752943f9b2f5b75f67557223": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "dcb841f5a77c4feb80166fa3ccdf3a72": {"model_name": "ToggleButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ToggleButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ToggleButtonView", "button_style": "", "description": "1", "description_tooltip": null, "disabled": false, "icon": "", "layout": "IPY_MODEL_db03e6cc86874ac5ae11261a93b0bcd7", "style": "IPY_MODEL_f27b637a752943f9b2f5b75f67557223", "tooltip": "", "value": false}}, "97ecc9f1f5704071ae3fcd5d12b0fe6f": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "6e6a3c8ca6a74576be02efdad0eda71c": {"model_name": "HBoxModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_b1bd45af4b2747b4890c52aa2e6464c5", "IPY_MODEL_f202f1296de146bca1abbb440e30d529", "IPY_MODEL_69015928a71444e4a976278b2ab212c1", "IPY_MODEL_01dac76d841c428785b73addca4e736f", "IPY_MODEL_dcb841f5a77c4feb80166fa3ccdf3a72"], "layout": "IPY_MODEL_97ecc9f1f5704071ae3fcd5d12b0fe6f"}}, "6412a58c6ae8448f9df88aefe238ec89": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "3a59af2d82c64dfc8fdec82b98428193": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "a01168b8fe324516823fea8fc609f0a3": {"model_name": "LabelModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "LabelModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "LabelView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_6412a58c6ae8448f9df88aefe238ec89", "placeholder": "\u200b", "style": "IPY_MODEL_3a59af2d82c64dfc8fdec82b98428193", "value": "Toggle the bits below to change the binary number."}}, "b1b5b2b2eb724394ae938b1c0cf7a199": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "67fb8db2833545d887dc6dd998646619": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "be33ea9874ad47769a4ff9fba60f758d": {"model_name": "LabelModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "LabelModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "LabelView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_b1b5b2b2eb724394ae938b1c0cf7a199", "placeholder": "\u200b", "style": "IPY_MODEL_67fb8db2833545d887dc6dd998646619", "value": "Think of a number between 0 and 31 and try to write it down in binary."}}, "5a378a369804464cb2f82551c5b4254d": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "a1040732a3184a6bb1d26a5a0a95bebb": {"model_name": "VBoxModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "VBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "VBoxView", "box_style": "", "children": ["IPY_MODEL_a01168b8fe324516823fea8fc609f0a3", "IPY_MODEL_be33ea9874ad47769a4ff9fba60f758d", "IPY_MODEL_6e6a3c8ca6a74576be02efdad0eda71c"], "layout": "IPY_MODEL_5a378a369804464cb2f82551c5b4254d"}}}, "version_major": 2, "version_minor": 0}
</script>


    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="notebooks.html" title="previous page">Content with notebooks</a>

    </div>
</main>


      </div>
    </div>

    <script src="_static/js/index.js"></script>
    
  </body>
